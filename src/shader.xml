<?xml version="1.0" encoding="ISO-8859-1"?>
<shader>
  <fragment>
    precision mediump float;
    
    varying vec3 vTransformedNormal;
    
    varying vec4 mvPosition;

    uniform float uMaterialShininess;
    uniform bool uUseSpecularMap;
    uniform bool uUseLighting;
    uniform bool uUseTextureAtlas;
    uniform float uAlpha;
    
    uniform mat3 uNMatrix;
    
    uniform vec3 uPointLightingVector;
    uniform vec3 uPointLightingSpecularColor;
    uniform vec3 uPointLightingDiffuseColor;
    uniform vec3 uAmbientColor;
    varying vec2 vTextureCoord;
    uniform sampler2D uSampler;
    uniform sampler2D uSpecularMapSampler;
    
    void main(void) { 
      vec3 vLightWeighting = vec3(1.0, 1.0, 1.0);
      if ( uUseLighting ) {
     
        vec3 lightDirection = normalize(uPointLightingVector - mvPosition.xyz);
        vec3 normal = normalize(vTransformedNormal);

        float specularLightWeighting = 0.0;
        vec4 shininess = vec4(1.0, 1.0, 1.0, 1.0);//uMaterialShininess;
        
        if ( uUseSpecularMap )
          shininess = texture2D(uSpecularMapSampler, vec2(vTextureCoord.s, vTextureCoord.t)).r * 255.0;
        
        if ( 255.0 > shininess) {
        
          vec3 eyeDirection = normalize( -mvPosition.xyz );
          vec3 reflectionDirection = reflect( -lightDirection, normal );

          specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), shininess);
          
        }

        float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
        vLightWeighting = uAmbientColor + uPointLightingSpecularColor * specularLightWeighting + uPointLightingDiffuseColor * diffuseLightWeighting;
      }
      
      vec4 textureColor = vec4(0.0, 1.0, 1.0, 1.0);

      if ( uUseTextureAtlas ) {
        //vec3 q0 = dFdx(mvPosition.xyz);
        //vec3 q1 = dFdy(mvPosition.xyz);
        //vec2 st0 = dFdx(vTextureCoord.st);
        //vec2 st1 = dFdy(vTextureCoord.st);
        //float Sx = ( q0.x * st1.t - q1.x * st0.t) / (st1.t * st0.s - st0.t * st1.s);
        //float Tx = (-q0.x * st1.s + q1.x * st0.s) / (st1.t * st0.s - st0.t * st1.s);
        textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
      }
      gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a * uAlpha);
    }
  </fragment>
  <vertex>
  
    uniform sampler2D uTerrain;
    uniform bool uUseTerrain;
    uniform float uFactor;
    
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec3 aVertexNormal;
    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;
    uniform vec3 aLookAtPointVector;
    uniform vec3 aCameraPositionVector;

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
    varying vec4 mvPosition;
    
    vec3 crossProduct (vec3 v1, vec3 v2){
      float x = v1.y * v2.z - v1.z * v2.y;
      float y = v1.z * v2.x - v1.x * v2.z;
      float z = v1.x * v2.y - v1.y * v2.x;
      vec3 product = vec3(x, y ,z);
      return product;
    }
    
    /*
    mat4 gluLookAt(vec3 eye, vec3 target, vec3 up){
      vec3 vz = normalize(eye - target);
      vec3 vx = normalize(crossProduct(up, vz));
      vec3 vy = crossProduct(vz, vx);
      mat4 inverseViewMatrix = mat4(vec4(vx, 0.0), vec4(vy, 0.0), vec4(vz, 0.0), vec4(eye, 1.0));
      return inverseViewMatrix;
    }
    */
    void main(void){
      //mat4 inverseMVMatrix = gluLookAt(aCameraPositionVector, aLookAtPointVector, vec3(0.0, 0.0, 1.0));
      vec4 cPos = vec4(aVertexPosition, 1.0);
      
      if (uUseTerrain){
        vec4 height_rgba = texture2D(uTerrain, aTextureCoord );//+ vec2( 0.5 ) );
        float height = height_rgba.r * 10.0;
        cPos = vec4( aVertexPosition.x, aVertexPosition.y, height, 1.0 );
      }
      
      mvPosition = uMVMatrix * cPos;
      gl_Position = uPMatrix * mvPosition;
      vTextureCoord = aTextureCoord;
      vTransformedNormal = uNMatrix * aVertexNormal;
    }
  </vertex> 
</shader>